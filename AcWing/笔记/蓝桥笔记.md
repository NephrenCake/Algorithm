# 蓝桥杯C++AB组课程笔记

[TOC]

## 第一讲 递归与递推

> 由数据范围反推算法复杂度以及算法内容。链接：https://www.acwing.com/blog/content/32/
>
> - 一般ACM或者笔试题的时间限制是1秒或2秒。
>   在这种情况下，C++代码中的操作次数控制在 10^7^∼10^8^为最佳。
> - 下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：
> - n≤30, 指数级别, dfs_abc+剪枝，状态压缩dp
>   n≤100 => O(n^3^)，floyd，dp，高斯消元
>   n≤1000 => O(n^2^)，O(n^2^logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford
>   n≤10000 => O(n∗√n)，块状链表、分块、莫队
>   n≤100000 => O(nlogn) => 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树
>   n≤1000000 => O(n), 以及常数较小的 O(nlogn) 算法 => 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa
>   n≤10000000 => O(n)，双指针扫描、kmp、AC自动机、线性筛素数
>   n≤10^9^ => O(√n)，判断质数
>   n≤10^18^ => O(logn)，最大公约数，快速幂，数位DP
>   n≤10^1000^ => O((logn)^2^)，高精度加减乘除
>   n≤10^100000^ => O(logk×loglogk)，k表示位数，高精度加减、FFT/NTT

题目描述 => 抽象出模型 <=> 检查时间复杂度

- 时间复杂度通常能够给解题方向提供思路，限定算法

递归：

- 指数型枚举
- 全排列型枚举
- 组合型枚举

全排列型枚举：

- 顺序1：依次枚举每个数放在哪个位置
- 顺序2：依次枚举每个位置放哪个数

组合型枚举：

- 和排列相似，但排列需要顺序，组合不要求顺序
- 将组合问题人为排序，即可以获得一个“不重”的答案
  - 限制从小大大排序：（局部）只需要保证每次新加的数都大于前面的数

考虑搜索树递归需要的参数

1. 结果/路径数组 ways[]
2. 当前应该枚举哪个位置
3. start 当前最小可以从哪个地方开始枚举

对于考试时

- 最先追求 AC
- 在常数比较小（硬代码量较少）的时候，可以考虑暴力

关于二维数组的定义

```bash
  	 y    ——→
x	| (x1, y1) | (x1, y2) |
↓   | (x2, y1) | (x2, y2) |
    | (x3, y1) | (x3, y2) |
```

由初试状态转移到最终状态的最短方案

- 一般使用 bfs

## 第二讲 二分与前缀和

